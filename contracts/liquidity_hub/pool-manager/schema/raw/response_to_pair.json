{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "PairInfoResponse",
  "type": "object",
  "required": [
    "pair_info"
  ],
  "properties": {
    "pair_info": {
      "$ref": "#/definitions/PairInfo"
    }
  },
  "additionalProperties": false,
  "definitions": {
    "Coin": {
      "type": "object",
      "required": [
        "amount",
        "denom"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "denom": {
          "type": "string"
        }
      }
    },
    "Decimal": {
      "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
      "type": "string"
    },
    "Fee": {
      "type": "object",
      "required": [
        "share"
      ],
      "properties": {
        "share": {
          "$ref": "#/definitions/Decimal"
        }
      },
      "additionalProperties": false
    },
    "PairInfo": {
      "type": "object",
      "required": [
        "asset_decimals",
        "asset_denoms",
        "assets",
        "lp_denom",
        "pair_type",
        "pool_fees"
      ],
      "properties": {
        "asset_decimals": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "uint8",
            "minimum": 0.0
          }
        },
        "asset_denoms": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "assets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Coin"
          }
        },
        "lp_denom": {
          "type": "string"
        },
        "pair_type": {
          "$ref": "#/definitions/PairType"
        },
        "pool_fees": {
          "$ref": "#/definitions/PoolFee"
        }
      },
      "additionalProperties": false
    },
    "PairType": {
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "constant_product"
          ]
        },
        {
          "type": "object",
          "required": [
            "stable_swap"
          ],
          "properties": {
            "stable_swap": {
              "type": "object",
              "required": [
                "amp"
              ],
              "properties": {
                "amp": {
                  "description": "The amount of amplification to perform on the constant product part of the swap formula.",
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "PoolFee": {
      "description": "Represents the fee structure for transactions within a pool.\n\n# Fields - `protocol_fee`: The fee percentage charged by the protocol on each transaction to support operational and developmental needs. - `swap_fee`: The fee percentage allocated to liquidity providers as a reward for supplying liquidity to the pool, incentivizing participation and ensuring pool health. - `burn_fee`: A fee percentage that is burned on each transaction, helping manage the token economy by reducing supply over time, potentially increasing token value. - `osmosis_fee` (optional): Specific to the Osmosis feature, this fee is charged on each transaction when the Osmosis feature is enabled, supporting specific ecosystem requirements. - `extra_fees`: A vector of custom fees allowing for extensible and adaptable fee structures to meet diverse and evolving needs. Validation ensures that the total of all fees does not exceed 100%, maintaining fairness and avoiding overcharging.\n\n# Features - `osmosis`: Enables the `osmosis_fee` field, integrating specific fee requirements for the Osmosis protocol within the pool's fee structure.",
      "type": "object",
      "required": [
        "burn_fee",
        "extra_fees",
        "protocol_fee",
        "swap_fee"
      ],
      "properties": {
        "burn_fee": {
          "description": "Fee percentage that is burned on each transaction. Burning a portion of the transaction fee helps in reducing the overall token supply.",
          "allOf": [
            {
              "$ref": "#/definitions/Fee"
            }
          ]
        },
        "extra_fees": {
          "description": "A list of custom, additional fees that can be defined for specific use cases or additional functionalities. This vector enables the flexibility to introduce new fees without altering the core fee structure. Total of all fees, including custom ones, is validated to not exceed 100%, ensuring a balanced and fair fee distribution.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Fee"
          }
        },
        "protocol_fee": {
          "description": "Fee percentage charged on each transaction for the protocol's benefit.",
          "allOf": [
            {
              "$ref": "#/definitions/Fee"
            }
          ]
        },
        "swap_fee": {
          "description": "Fee percentage allocated to liquidity providers on each swap.",
          "allOf": [
            {
              "$ref": "#/definitions/Fee"
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    }
  }
}
