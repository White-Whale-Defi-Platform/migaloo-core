{
  "contract_name": "xtask",
  "contract_version": "1.0.6",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "fee_distributor_address",
      "lp_asset"
    ],
    "properties": {
      "fee_distributor_address": {
        "description": "Fee distributor contract address.",
        "type": "string"
      },
      "lp_asset": {
        "description": "The address of the LP token that the incentive should be tied to.",
        "allOf": [
          {
            "$ref": "#/definitions/AssetInfo"
          }
        ]
      }
    },
    "additionalProperties": false,
    "definitions": {
      "AssetInfo": {
        "description": "AssetInfo contract_addr is usually passed from the cw20 hook so we can trust the contract_addr is properly validated.",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "token"
            ],
            "properties": {
              "token": {
                "type": "object",
                "required": [
                  "contract_addr"
                ],
                "properties": {
                  "contract_addr": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "native_token"
            ],
            "properties": {
              "native_token": {
                "type": "object",
                "required": [
                  "denom"
                ],
                "properties": {
                  "denom": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Makes a snapshot of the current global weight, at the current epoch.",
        "type": "object",
        "required": [
          "take_global_weight_snapshot"
        ],
        "properties": {
          "take_global_weight_snapshot": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Opens a new liquidity flow",
        "type": "object",
        "required": [
          "open_flow"
        ],
        "properties": {
          "open_flow": {
            "type": "object",
            "required": [
              "flow_asset"
            ],
            "properties": {
              "curve": {
                "description": "The type of distribution curve. If unspecified, the distribution will be linear.",
                "anyOf": [
                  {
                    "$ref": "#/definitions/Curve"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "end_epoch": {
                "description": "The epoch at which the flow should end. If unspecified, the flow will default to end at 14 epochs from the current one.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "flow_asset": {
                "description": "The asset to be distributed in this flow.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Asset"
                  }
                ]
              },
              "flow_label": {
                "description": "If set, the label will be used to identify the flow, in addition to the flow_id.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "start_epoch": {
                "description": "The epoch at which the flow will start. If unspecified, the flow will start at the current epoch.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Closes an existing liquidity flow.\n\nSender of the message must either be the contract admin or the creator of the flow.",
        "type": "object",
        "required": [
          "close_flow"
        ],
        "properties": {
          "close_flow": {
            "type": "object",
            "required": [
              "flow_identifier"
            ],
            "properties": {
              "flow_identifier": {
                "description": "The identifier of the flow to close.",
                "allOf": [
                  {
                    "$ref": "#/definitions/FlowIdentifier"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Creates a new position to earn flow rewards.",
        "type": "object",
        "required": [
          "open_position"
        ],
        "properties": {
          "open_position": {
            "type": "object",
            "required": [
              "amount",
              "unbonding_duration"
            ],
            "properties": {
              "amount": {
                "description": "The amount to add to the position.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              },
              "receiver": {
                "description": "The receiver of the new position.\n\nThis is mostly used for the frontend helper contract.\n\nIf left empty, defaults to the message sender.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "unbonding_duration": {
                "description": "The amount of time (in seconds) before the LP tokens can be redeemed.",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Expands an existing position to earn more flow rewards.",
        "type": "object",
        "required": [
          "expand_position"
        ],
        "properties": {
          "expand_position": {
            "type": "object",
            "required": [
              "amount",
              "unbonding_duration"
            ],
            "properties": {
              "amount": {
                "description": "The amount to add to the existing position.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ]
              },
              "receiver": {
                "description": "The receiver of the expanded position.\n\nThis is mostly used for the frontend helper contract.\n\nIf left empty, defaults to the message sender.",
                "type": [
                  "string",
                  "null"
                ]
              },
              "unbonding_duration": {
                "description": "The unbond completion timestamp to identify the position to add to.",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Closes an existing position to stop earning flow rewards.",
        "type": "object",
        "required": [
          "close_position"
        ],
        "properties": {
          "close_position": {
            "type": "object",
            "required": [
              "unbonding_duration"
            ],
            "properties": {
              "unbonding_duration": {
                "description": "The unbonding duration of the position to close.",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Withdraws the LP tokens from a closed position once the unbonding duration has passed.",
        "type": "object",
        "required": [
          "withdraw"
        ],
        "properties": {
          "withdraw": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Claims the flow rewards.",
        "type": "object",
        "required": [
          "claim"
        ],
        "properties": {
          "claim": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Expands an existing flow.",
        "type": "object",
        "required": [
          "expand_flow"
        ],
        "properties": {
          "expand_flow": {
            "type": "object",
            "required": [
              "flow_asset",
              "flow_identifier"
            ],
            "properties": {
              "end_epoch": {
                "description": "The epoch at which the flow should end. If not set, the flow will be expanded a default value of 14 epochs.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "flow_asset": {
                "description": "The asset to expand this flow with.",
                "allOf": [
                  {
                    "$ref": "#/definitions/Asset"
                  }
                ]
              },
              "flow_identifier": {
                "description": "The identifier of the flow to expand, whether an id or a label.",
                "allOf": [
                  {
                    "$ref": "#/definitions/FlowIdentifier"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "Asset": {
        "type": "object",
        "required": [
          "amount",
          "info"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "info": {
            "$ref": "#/definitions/AssetInfo"
          }
        },
        "additionalProperties": false
      },
      "AssetInfo": {
        "description": "AssetInfo contract_addr is usually passed from the cw20 hook so we can trust the contract_addr is properly validated.",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "token"
            ],
            "properties": {
              "token": {
                "type": "object",
                "required": [
                  "contract_addr"
                ],
                "properties": {
                  "contract_addr": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "native_token"
            ],
            "properties": {
              "native_token": {
                "type": "object",
                "required": [
                  "denom"
                ],
                "properties": {
                  "denom": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Curve": {
        "description": "The type of distribution curve to exist.",
        "oneOf": [
          {
            "description": "A linear curve that releases assets as we approach the end of the flow period.",
            "type": "string",
            "enum": [
              "linear"
            ]
          }
        ]
      },
      "FlowIdentifier": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "label"
            ],
            "properties": {
              "label": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Retrieves the current contract configuration.",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Retrieves a specific flow. If start_epoch and end_epoch are set, the asset_history and emitted_tokens will be filtered to only include epochs within the range. The maximum gap between the start_epoch and end_epoch is 100 epochs.",
        "type": "object",
        "required": [
          "flow"
        ],
        "properties": {
          "flow": {
            "type": "object",
            "required": [
              "flow_identifier"
            ],
            "properties": {
              "end_epoch": {
                "description": "If set, filters the asset_history and emitted_tokens to only include epochs until end_epoch.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "flow_identifier": {
                "description": "The id of the flow to find.",
                "allOf": [
                  {
                    "$ref": "#/definitions/FlowIdentifier"
                  }
                ]
              },
              "start_epoch": {
                "description": "If set, filters the asset_history and emitted_tokens to only include epochs from start_epoch.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Retrieves the current flows. If start_epoch and end_epoch are set, the asset_history and emitted_tokens will be filtered to only include epochs within the range. The maximum gap between the start_epoch and end_epoch is 100 epochs.",
        "type": "object",
        "required": [
          "flows"
        ],
        "properties": {
          "flows": {
            "type": "object",
            "properties": {
              "end_epoch": {
                "description": "If set, filters the asset_history and emitted_tokens to only include epochs until end_epoch.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              },
              "start_epoch": {
                "description": "If set, filters the asset_history and emitted_tokens to only include epochs from start_epoch.",
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Retrieves the positions for an address.",
        "type": "object",
        "required": [
          "positions"
        ],
        "properties": {
          "positions": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "description": "The address to get positions for.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Retrieves the rewards for an address.",
        "type": "object",
        "required": [
          "rewards"
        ],
        "properties": {
          "rewards": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "description": "The address to get all the incentive rewards for.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Retrieves the rewards for an address.",
        "type": "object",
        "required": [
          "global_weight"
        ],
        "properties": {
          "global_weight": {
            "type": "object",
            "required": [
              "epoch_id"
            ],
            "properties": {
              "epoch_id": {
                "description": "The epoch to get the global weight for.",
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Retrieves the rewards/weight share of an address for the current epoch.",
        "type": "object",
        "required": [
          "current_epoch_rewards_share"
        ],
        "properties": {
          "current_epoch_rewards_share": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "description": "The address to query the rewards share for.",
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "FlowIdentifier": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "label"
            ],
            "properties": {
              "label": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "migrate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "MigrateMsg",
    "type": "object",
    "additionalProperties": false
  },
  "sudo": null,
  "responses": {
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config",
      "description": "Represents the configuration of the incentive contract.",
      "type": "object",
      "required": [
        "factory_address",
        "fee_distributor_address",
        "lp_asset"
      ],
      "properties": {
        "factory_address": {
          "description": "The address of the incentive factory.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "fee_distributor_address": {
          "description": "Fee distributor contract.",
          "allOf": [
            {
              "$ref": "#/definitions/Addr"
            }
          ]
        },
        "lp_asset": {
          "description": "The LP token asset tied to the incentive contract.",
          "allOf": [
            {
              "$ref": "#/definitions/AssetInfo"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "AssetInfo": {
          "description": "AssetInfo contract_addr is usually passed from the cw20 hook so we can trust the contract_addr is properly validated.",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        }
      }
    },
    "current_epoch_rewards_share": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "RewardsShareResponse",
      "type": "object",
      "required": [
        "address",
        "address_weight",
        "epoch_id",
        "global_weight",
        "share"
      ],
      "properties": {
        "address": {
          "$ref": "#/definitions/Addr"
        },
        "address_weight": {
          "$ref": "#/definitions/Uint128"
        },
        "epoch_id": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "global_weight": {
          "$ref": "#/definitions/Uint128"
        },
        "share": {
          "$ref": "#/definitions/Decimal256"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Decimal256": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal256(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 115792089237316195423570985008687907853269984665640564039457.584007913129639935 (which is (2^256 - 1) / 10^18)",
          "type": "string"
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "flow": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FlowResponse",
      "type": "object",
      "properties": {
        "flow": {
          "description": "The flow that was searched for.",
          "anyOf": [
            {
              "$ref": "#/definitions/Flow"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Asset": {
          "type": "object",
          "required": [
            "amount",
            "info"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "info": {
              "$ref": "#/definitions/AssetInfo"
            }
          },
          "additionalProperties": false
        },
        "AssetInfo": {
          "description": "AssetInfo contract_addr is usually passed from the cw20 hook so we can trust the contract_addr is properly validated.",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Curve": {
          "description": "The type of distribution curve to exist.",
          "oneOf": [
            {
              "description": "A linear curve that releases assets as we approach the end of the flow period.",
              "type": "string",
              "enum": [
                "linear"
              ]
            }
          ]
        },
        "Flow": {
          "description": "Represents a flow.",
          "type": "object",
          "required": [
            "asset_history",
            "claimed_amount",
            "curve",
            "emitted_tokens",
            "end_epoch",
            "flow_asset",
            "flow_creator",
            "flow_id",
            "start_epoch"
          ],
          "properties": {
            "asset_history": {
              "description": "A map containing the amount of tokens it was expanded to at a given epoch. This is used to calculate the right amount of tokens to distribute at a given epoch when a flow is expanded.",
              "type": "object",
              "additionalProperties": {
                "type": "array",
                "items": [
                  {
                    "$ref": "#/definitions/Uint128"
                  },
                  {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "claimed_amount": {
              "description": "The amount of the `flow_asset` that has been claimed so far.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "curve": {
              "description": "The type of curve the flow has.",
              "allOf": [
                {
                  "$ref": "#/definitions/Curve"
                }
              ]
            },
            "emitted_tokens": {
              "description": "emitted tokens",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "end_epoch": {
              "description": "The epoch at which the flow ends.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "flow_asset": {
              "description": "The asset the flow was created to distribute.",
              "allOf": [
                {
                  "$ref": "#/definitions/Asset"
                }
              ]
            },
            "flow_creator": {
              "description": "The account which opened the flow and can manage it.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "flow_id": {
              "description": "A unique identifier of the flow.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "flow_label": {
              "description": "An alternative flow label.",
              "type": [
                "string",
                "null"
              ]
            },
            "start_epoch": {
              "description": "The epoch at which the flow starts.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "flows": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FlowsResponse",
      "type": "object",
      "required": [
        "flows"
      ],
      "properties": {
        "flows": {
          "description": "The current flows.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Flow"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "Asset": {
          "type": "object",
          "required": [
            "amount",
            "info"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "info": {
              "$ref": "#/definitions/AssetInfo"
            }
          },
          "additionalProperties": false
        },
        "AssetInfo": {
          "description": "AssetInfo contract_addr is usually passed from the cw20 hook so we can trust the contract_addr is properly validated.",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Curve": {
          "description": "The type of distribution curve to exist.",
          "oneOf": [
            {
              "description": "A linear curve that releases assets as we approach the end of the flow period.",
              "type": "string",
              "enum": [
                "linear"
              ]
            }
          ]
        },
        "Flow": {
          "description": "Represents a flow.",
          "type": "object",
          "required": [
            "asset_history",
            "claimed_amount",
            "curve",
            "emitted_tokens",
            "end_epoch",
            "flow_asset",
            "flow_creator",
            "flow_id",
            "start_epoch"
          ],
          "properties": {
            "asset_history": {
              "description": "A map containing the amount of tokens it was expanded to at a given epoch. This is used to calculate the right amount of tokens to distribute at a given epoch when a flow is expanded.",
              "type": "object",
              "additionalProperties": {
                "type": "array",
                "items": [
                  {
                    "$ref": "#/definitions/Uint128"
                  },
                  {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "claimed_amount": {
              "description": "The amount of the `flow_asset` that has been claimed so far.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "curve": {
              "description": "The type of curve the flow has.",
              "allOf": [
                {
                  "$ref": "#/definitions/Curve"
                }
              ]
            },
            "emitted_tokens": {
              "description": "emitted tokens",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "end_epoch": {
              "description": "The epoch at which the flow ends.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "flow_asset": {
              "description": "The asset the flow was created to distribute.",
              "allOf": [
                {
                  "$ref": "#/definitions/Asset"
                }
              ]
            },
            "flow_creator": {
              "description": "The account which opened the flow and can manage it.",
              "allOf": [
                {
                  "$ref": "#/definitions/Addr"
                }
              ]
            },
            "flow_id": {
              "description": "A unique identifier of the flow.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            },
            "flow_label": {
              "description": "An alternative flow label.",
              "type": [
                "string",
                "null"
              ]
            },
            "start_epoch": {
              "description": "The epoch at which the flow starts.",
              "type": "integer",
              "format": "uint64",
              "minimum": 0.0
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "global_weight": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "GlobalWeightResponse",
      "type": "object",
      "required": [
        "epoch_id",
        "global_weight"
      ],
      "properties": {
        "epoch_id": {
          "description": "Epoch id for which the global weight is calculated",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "global_weight": {
          "description": "the global weight of the incentive contract for the given epoch",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "positions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PositionsResponse",
      "type": "object",
      "required": [
        "positions",
        "timestamp"
      ],
      "properties": {
        "positions": {
          "description": "All the positions a user has.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/QueryPosition"
          }
        },
        "timestamp": {
          "description": "The current time of the blockchain.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false,
      "definitions": {
        "QueryPosition": {
          "oneOf": [
            {
              "description": "Represents a position that a user has deposited, but not yet begun to unbond.",
              "type": "object",
              "required": [
                "open_position"
              ],
              "properties": {
                "open_position": {
                  "type": "object",
                  "required": [
                    "amount",
                    "unbonding_duration",
                    "weight"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of LP tokens the user deposited into the position.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Uint128"
                        }
                      ]
                    },
                    "unbonding_duration": {
                      "description": "The amount of time (in seconds) the user must wait after they begin the unbonding process.",
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "weight": {
                      "description": "The amount of weight the position has.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Uint128"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Represents a position that a user has initiated the unbonding process on. The position may or may not be withdrawable.",
              "type": "object",
              "required": [
                "closed_position"
              ],
              "properties": {
                "closed_position": {
                  "type": "object",
                  "required": [
                    "amount",
                    "unbonding_timestamp",
                    "weight"
                  ],
                  "properties": {
                    "amount": {
                      "description": "The amount of LP tokens the user deposited into the position, and will receive after they withdraw.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Uint128"
                        }
                      ]
                    },
                    "unbonding_timestamp": {
                      "description": "The timestamp (in seconds) the user unbonded at.",
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    },
                    "weight": {
                      "description": "The amount of weight the position has.",
                      "allOf": [
                        {
                          "$ref": "#/definitions/Uint128"
                        }
                      ]
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "rewards": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "RewardsResponse",
      "type": "object",
      "required": [
        "rewards"
      ],
      "properties": {
        "rewards": {
          "description": "The rewards that is available to a user if they executed the `claim` function at this point.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Asset"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Asset": {
          "type": "object",
          "required": [
            "amount",
            "info"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "info": {
              "$ref": "#/definitions/AssetInfo"
            }
          },
          "additionalProperties": false
        },
        "AssetInfo": {
          "description": "AssetInfo contract_addr is usually passed from the cw20 hook so we can trust the contract_addr is properly validated.",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "token"
              ],
              "properties": {
                "token": {
                  "type": "object",
                  "required": [
                    "contract_addr"
                  ],
                  "properties": {
                    "contract_addr": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "native_token"
              ],
              "properties": {
                "native_token": {
                  "type": "object",
                  "required": [
                    "denom"
                  ],
                  "properties": {
                    "denom": {
                      "type": "string"
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    }
  }
}
